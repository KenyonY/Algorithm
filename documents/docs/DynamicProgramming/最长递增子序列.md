### 最长递增子序列

动态规划的核心设计思想是数学归纳法。

>最简单和常见的数学归纳法是证明当*n*等于任意一个自然数时某命题成立。证明分两步：
>
>1. 证明当*n*= 1时命题成立。
>2. 然后证明从n=m 成立可以推导出n=*m*+1 （*m*代表任意自然数）也成立，则命题得证。（这里实际应用的是[演绎推理](https://baike.baidu.com/item/演绎推理)）
>
>这种方法的原理在于：首先证明在某个起点值时命题成立，然后证明从一个值到下一个值的过程有效。当这两点都已经证明，那么任意值都可以通过反复使用这个方法推导出来。把这个方法想成[多米诺效应](https://baike.baidu.com/item/多米诺效应)也许更容易理解一些。

应该说，数学归纳法与动态规划的本质是相同的。数学归纳法是从n=1开始向后迭代证明命题或者公式成立，递推是从n=1开始向后迭代计算命题的值。

所以数学归纳法的证明方式是假设命题在n成立时如果能推导出n+1时也成立，则命题能得证；

而动态规划的计算方式是 假设命题在n出的值我们已经得到，那么如果能通过n计算出n+1出的值，我们便可以通过初始值计算出所有的值。

**例题：**

> 给定一个无序的整数数组，找到其中最长上升子序列的长度。
>
> 示例：
>
> ```
> 输入： [10, 9, 2, 5, 3, 7, 101, 18] 
> 输出：4 
> 解释：最长上升子序列是[2, 3, 7, 101], 它的长度是4. 
> ```

<font size=2>*注：「子序列」和「子串」这两个名词的区别，子串必须是连续的，而子序列不一定是连续的。* </font>

思路：

从这个整数数组的第一个位置开始，使用table数组来记录下该位置的最长序列长度。

这样下一个位置的最长长度，只需找到在这个table中比该位置上的数小的最大长度即可。

故用两个循环即可实现：

```python
def longSeq(Seq):
    table = len(Seq) * [1]
    for idx, i in enumerate(Seq):
        for j in range(idx+1):
            if Seq[j] < i:
                table[idx] = max(table[idx], table[j]+1)
    return max(table)
```

以上代码复杂度为$O(n^2)$ 

因为上面代码中第二个循环在table中查找使用的是线性查找，显然可以替换为二分查找，这样便可将复杂度降为$O(n \log(n))$ 。

