> 给定一个无序的整数数组，找到其中最长上升子序列的长度。
>
> 示例：
>
> ```
> 输入： [10, 9, 2, 5, 3, 7, 101, 18] 
> 输出：4 
> 解释：最长上升子序列是[2, 3, 7, 101], 它的长度是4. 
> ```

<font size=2>*注：「子序列」和「子串」这两个名词的区别，子串必须是连续的，而子序列不一定是连续的。* </font>

思路：

从这个整数数组的第一个位置开始，使用table数组来记录下该位置的最长序列长度。

这样下一个位置的最长长度，只需找到在这个table中比该位置上的数小的最大长度即可。

故用两个循环即可实现：

```python
def longSeq(Seq):
    table = len(Seq) * [1]
    for idx, i in enumerate(Seq):
        for j in range(idx+1):
            if Seq[j] < i:
                table[idx] = max(table[idx], table[j]+1)
    return max(table)
```

以上代码复杂度为$O(n^2)$ 

因为上面代码中第二个循环在table中查找使用的是线性查找，显然可以替换为二分查找，这样便可将复杂度降为$O(n \log(n))$ 。

